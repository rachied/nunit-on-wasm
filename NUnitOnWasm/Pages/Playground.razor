@page "/playground"
@using Microsoft.CodeAnalysis.CSharp
@using Microsoft.CodeAnalysis
@using Microsoft.CodeAnalysis.Emit
@using System.Reflection
@using System.Text
@using NUnit.Common
@using NUnitLite
@using NUnitOnWasm.TestRunner
<h3>Playground</h3>

<button onclick="@(async () => await CompileAndRun())">Run</button>
<StandaloneCodeEditor @ref="_editor" Id="code-editor" ConstructionOptions="EditorConstructionOptions" />

@code {

    [Inject] 
    public IJSRuntime JsRuntime { get; set; }

    [Inject]
    public HttpClient HttpClient { get; set; }
    
    private StandaloneCodeEditor _editor { get; set; }

    private string _testCode = @"using System;
using NUnit.Framework;
using System.Threading;

namespace PlaygroundExecution 
{
    [TestFixture]
    public class UnitTests
    {
        [Test]
        public void PassingTest()
        {
            Assert.That(1 == 1);
        }

        [TestCase(40,40)]
        public void Parameterized_Test(int a, int b)
        {
            Assert.That(a == b);
        }
    }
}";

    List<MetadataReference> References = new();
    
    private StandaloneEditorConstructionOptions EditorConstructionOptions(StandaloneCodeEditor editor)
    {
        return new StandaloneEditorConstructionOptions
        {
            AutomaticLayout = true,
            Language = "csharp",
            Value = _testCode,
        };
    }

    public async Task CompileAndRun()
    {
        var code = await _editor.GetValue();
        var assembly = await CompileToAssembly(code);
        var result = RunTestsCustom(assembly);

        var msg = result switch {
            0 => "All tests passed, nice!",
            1 => "One or more tests failed",
            _ => $"An unexpected error occurred, resultCode={result}",
            };

        await Alert(msg);
    }

    public async Task<Assembly> CompileToAssembly(string sourceCode)
    {
        await AddNetCoreDefaultReferences();
        
        var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary, concurrentBuild: false, optimizationLevel: OptimizationLevel.Release)
            .WithUsings("System", "System.Text", "System.Collections.Generic", "System.IO", "System.Linq", "System.Threading", "System.Threading.Tasks");
        
        var tree = SyntaxFactory.ParseSyntaxTree(sourceCode.Trim());
        var compilation = CSharpCompilation.Create("Program.cs")
            .WithOptions(compilationOptions)
            .WithReferences(References)
            .AddSyntaxTrees(tree);

        Stream codeStream;
        await using (codeStream = new MemoryStream())
        {
            // Actually compile the code
            var compilationResult = compilation.Emit(codeStream);

            // Compilation Error handling
            if (!compilationResult.Success)
            {
                await OnCompilationError(compilationResult);
            }
    
            // Load
            return Assembly.Load(((MemoryStream)codeStream).ToArray());
        }
    }

    public async Task OnCompilationError(EmitResult compilationResult)
    {
        var sb = new StringBuilder("Build failed\n");
        foreach (var diag in compilationResult.Diagnostics)
        {
            sb.AppendLine(diag.ToString());
        }
        var errorMessage = sb.ToString();

        if (errorMessage.Length > 0)
        {
            await Alert(errorMessage);
            throw new ApplicationException(errorMessage);
        }
    }

    private async Task Alert(string message)
    {
        await JsRuntime.InvokeVoidAsync("alert", message);
    }

    public dynamic RunEntryPoint(Assembly assembly, string[] args = null)
    {
        dynamic instance = assembly.CreateInstance("PlaygroundExecution.Program");
        
        var result = instance.Main(args);
        
        Console.WriteLine("Roslyn execution returned: " + result);

        return result;
    }

    public int RunTests(Assembly assembly)
    {
        var writer = new ExtendedTextWrapper(Console.Out);
        var result = new AutoRun(assembly).Execute(new string[] { "--noresult", "--stoponerror", "--labels=ON" }, writer, TextReader.Null);
        
        Console.WriteLine("NUnitLite execution returned: " + result);

        return result;
    }
    
    public int RunTestsCustom(Assembly assembly)
    {
        var args = new[] { "--noresult", "--labels=ON" };
        var writer = new ExtendedTextWrapper(Console.Out);
        var result = new WasmRunner(assembly).Execute(writer, TextReader.Null, args);
        
        Console.WriteLine("NUnitLite execution returned: " + result);

        return result;
    }

    public async Task AddNetCoreDefaultReferences()
    {
        string[] defaultLibs =
        {
            "/_framework/System.dll",
            "/_framework/System.Buffers.dll",
            "/_framework/System.Collections.dll",
            "/_framework/System.Core.dll",
            "/_framework/System.Runtime.dll",
            "/_framework/System.IO.dll",
            "/_framework/System.Linq.dll",
            "/_framework/System.Linq.Expressions.dll",
            "/_framework/System.Linq.Parallel.dll",
            "/_framework/mscorlib.dll",
            "/_framework/netstandard.dll",
            "/_framework/System.Private.CoreLib.dll",
            "/_framework/NUnit.Framework.dll",
        };
        
        List<string> libraries = new (defaultLibs);

        foreach (var libPath in libraries)
        {
            await using var referenceStream = await HttpClient.GetStreamAsync(libPath);
            References.Add(MetadataReference.CreateFromStream(referenceStream));
        }
    }
}