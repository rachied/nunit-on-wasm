@page "/playground"
@using Microsoft.CodeAnalysis.CSharp
@using Microsoft.CodeAnalysis
@using Microsoft.CodeAnalysis.Emit
@using System.Reflection
@using System.Text
@using NUnit.Common
@using NUnitLite
<h3>Playground</h3>


<textarea>
</textarea>

<button onclick="@(async () => await CompileAndRun())">Run</button>

@code {

    [Inject]
    public HttpClient HttpClient { get; set; }
    
    private List<Stream> LibStreams = new();
    
    private string _sourceCode = @"using System;

namespace PlaygroundExecution {
public class Program { 

    public int Main(string[] args)
    {
        return 42;
    }

} }";

    List<MetadataReference> References = new();

    public async Task CompileAndRun()
    {
        var assembly = await CompileToAssembly(_sourceCode);
        var result = RunEntryPoint(assembly);
    }

    public async Task<Assembly> CompileToAssembly(string sourceCode)
    {
        await AddNetCoreDefaultReferences();
        
        var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary, concurrentBuild: false, optimizationLevel: OptimizationLevel.Release)
            .WithUsings("System", "System.Text", "System.Collections.Generic", "System.IO", "System.Linq", "System.Threading", "System.Threading.Tasks");
        
        var tree = SyntaxFactory.ParseSyntaxTree(sourceCode.Trim());
        var compilation = CSharpCompilation.Create("Program.cs")
            .WithOptions(compilationOptions)
            .WithReferences(References)
            .AddSyntaxTrees(tree);

        Stream codeStream;
        await using (codeStream = new MemoryStream())
        {
            // Actually compile the code
            var compilationResult = compilation.Emit(codeStream);

            // Compilation Error handling
            if (!compilationResult.Success)
            {
                OnCompilationError(compilationResult);
            }
    
            // Load
            return Assembly.Load(((MemoryStream)codeStream).ToArray());
        }
    }

    public void OnCompilationError(EmitResult compilationResult)
    {
        var sb = new StringBuilder();
        foreach (var diag in compilationResult.Diagnostics)
        {
            sb.AppendLine(diag.ToString());
        }
        var errorMessage = sb.ToString();

        if (errorMessage.Length > 0)
        {
            throw new ApplicationException(errorMessage);
        }

        return;
    }

    public dynamic RunEntryPoint(Assembly assembly, string[] args = null)
    {
        dynamic instance = assembly.CreateInstance("PlaygroundExecution.Program");
        
        var result = instance.Main(args);
        
        Console.WriteLine("Roslyn execution returned: " + result);

        return result;
    }

    public void RunTests(Assembly assembly)
    {
        var writer = new ExtendedTextWrapper(Console.Out);
        var result = new AutoRun(assembly).Execute(new string[] { "--noresult", "--stoponerror", "--labels=ON" }, writer, Console.In);
        
        Console.WriteLine("NUnitLite execution returned: " + result);
    }

    public async Task AddNetCoreDefaultReferences()
    {
        string[] defaultLibs =
        {
            "/_framework/System.dll",
            "/_framework/System.Buffers.dll",
            "/_framework/System.Collections.dll",
            "/_framework/System.Core.dll",
            "/_framework/System.Runtime.dll",
            "/_framework/System.IO.dll",
            "/_framework/System.Linq.dll",
            "/_framework/System.Linq.Expressions.dll",
            "/_framework/System.Linq.Parallel.dll",
            "/_framework/mscorlib.dll",
            "/_framework/System.Private.CoreLib.dll"
        };
        
        List<string> libraries = new (defaultLibs);

        foreach (var libPath in libraries)
        {
            var referenceStream = await HttpClient.GetStreamAsync(libPath);
            LibStreams.Add(referenceStream);
            References.Add(MetadataReference.CreateFromStream(referenceStream));
        }
    }
}